{"version":3,"sources":["formatNumber.ts"],"names":["addSignPrefixAndSuffix","value","options","prefix","sign","suffix","signPosition","input","precision","separator","delimiter","ignoreNegative","showPositiveSign","negative","string","Math","abs","toFixed","parts","split","buffer","number","length","unshift","substr","max","formattedNumber","join","decimals"],"mappings":"AASA,OAAO,MAAMA,sBAAsB,GAAG,CACpCC,KADoC,EAEpCC,OAFoC,KAGjC;AACH,QAAM;AAAEC,IAAAA,MAAF;AAAUC,IAAAA,IAAV;AAAgBC,IAAAA,MAAhB;AAAwBC,IAAAA;AAAxB,MAAyCJ,OAA/C;;AAEA,UAAQI,YAAR;AACE,SAAK,cAAL;AACE,uBAAUF,IAAV,SAAiBD,MAAjB,SAA0BF,KAA1B,SAAkCI,MAAlC;;AACF,SAAK,aAAL;AACE,uBAAUF,MAAV,SAAmBC,IAAnB,SAA0BH,KAA1B,SAAkCI,MAAlC;AAJJ;AAMD,CAZM;AAcP,gBAAe,CAACE,KAAD,EAAgBL,OAAhB,KAAkD;AAC/D,QAAM;AACJM,IAAAA,SADI;AAEJC,IAAAA,SAAS,GAAG,GAFR;AAGJC,IAAAA,SAAS,GAAG,GAHR;AAIJP,IAAAA,MAAM,GAAG,EAJL;AAKJE,IAAAA,MAAM,GAAG,EALL;AAMJM,IAAAA,cANI;AAOJC,IAAAA,gBAPI;AAQJN,IAAAA,YAAY,GAAG;AARX,MASFJ,OAAO,IAAI,EATf;AAWA,QAAMW,QAAQ,GAAGF,cAAc,GAAG,KAAH,GAAWJ,KAAK,GAAG,CAAlD;AACA,QAAMH,IAAI,GAAGS,QAAQ,GAAG,GAAH,GAASD,gBAAgB,GAAG,GAAH,GAAS,EAAvD;AAEA,QAAME,MAAM,GAAGC,IAAI,CAACC,GAAL,CAAST,KAAT,EAAgBU,OAAhB,CAAwBT,SAAxB,CAAf;AAEA,QAAMU,KAAK,GAAGJ,MAAM,CAACK,KAAP,CAAa,GAAb,CAAd;AACA,QAAMC,MAAM,GAAG,EAAf;AAEA,MAAIC,MAAM,GAAGH,KAAK,CAAC,CAAD,CAAlB;;AACA,SAAOG,MAAM,CAACC,MAAP,GAAgB,CAAvB,EAA0B;AACxBF,IAAAA,MAAM,CAACG,OAAP,CAAeF,MAAM,CAACG,MAAP,CAAcT,IAAI,CAACU,GAAL,CAAS,CAAT,EAAYJ,MAAM,CAACC,MAAP,GAAgB,CAA5B,CAAd,EAA8C,CAA9C,CAAf;AACAD,IAAAA,MAAM,GAAGA,MAAM,CAACG,MAAP,CAAc,CAAd,EAAiBH,MAAM,CAACC,MAAP,GAAgB,CAAjC,CAAT;AACD;;AAED,MAAII,eAAe,GAAG,EAAtB;AACAA,EAAAA,eAAe,GAAGN,MAAM,CAACO,IAAP,CAAYjB,SAAZ,CAAlB;AAEA,QAAMkB,QAAQ,GAAGV,KAAK,CAAC,CAAD,CAAtB;;AACA,MAAI,CAAC,CAACV,SAAF,IAAeoB,QAAnB,EAA6B;AAC3BF,IAAAA,eAAe,IAAIjB,SAAS,GAAGmB,QAA/B;AACD;;AAED,SAAO5B,sBAAsB,CAAC0B,eAAD,EAAkB;AAC7CvB,IAAAA,MAD6C;AAE7CE,IAAAA,MAF6C;AAG7CD,IAAAA,IAH6C;AAI7CE,IAAAA;AAJ6C,GAAlB,CAA7B;AAMD,CAxCD","sourcesContent":["import type { FormatNumberOptions } from '../props';\n\ninterface AddSignPrefixAndSuffixProps {\n  sign?: '+' | '-' | '';\n  prefix?: string;\n  suffix?: string;\n  signPosition: 'beforePrefix' | 'afterPrefix';\n}\n\nexport const addSignPrefixAndSuffix = (\n  value: any,\n  options: AddSignPrefixAndSuffixProps\n) => {\n  const { prefix, sign, suffix, signPosition } = options;\n\n  switch (signPosition) {\n    case 'beforePrefix':\n      return `${sign}${prefix}${value}${suffix}`;\n    case 'afterPrefix':\n      return `${prefix}${sign}${value}${suffix}`;\n  }\n};\n\nexport default (input: number, options?: FormatNumberOptions) => {\n  const {\n    precision,\n    separator = ',',\n    delimiter = '.',\n    prefix = '',\n    suffix = '',\n    ignoreNegative,\n    showPositiveSign,\n    signPosition = 'afterPrefix',\n  } = options || {};\n\n  const negative = ignoreNegative ? false : input < 0;\n  const sign = negative ? '-' : showPositiveSign ? '+' : '';\n\n  const string = Math.abs(input).toFixed(precision);\n\n  const parts = string.split('.');\n  const buffer = [];\n\n  let number = parts[0];\n  while (number.length > 0) {\n    buffer.unshift(number.substr(Math.max(0, number.length - 3), 3));\n    number = number.substr(0, number.length - 3);\n  }\n\n  let formattedNumber = '';\n  formattedNumber = buffer.join(delimiter);\n\n  const decimals = parts[1];\n  if (!!precision && decimals) {\n    formattedNumber += separator + decimals;\n  }\n\n  return addSignPrefixAndSuffix(formattedNumber, {\n    prefix,\n    suffix,\n    sign,\n    signPosition,\n  });\n};\n"]}